package com.Study7;

/**
 * ClassName Study7_1
 *
 * @Date2025/2/282:11
 * @Create bysunlight
 */
public class Study7_1 {


    /**
     * 面向对象三大特征：
     *      1.封装：
     *              对象的封装，javaBean结构
     *      2.继承：
     *
     *          public class 子类 extends 父类()
     *
     *          Java当中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系
     *
     *          当类与类之间，存在相同的内容，并满足子类是父类中的一种，就可以考虑继承，来优化代码、
     *
     *          特点：
     *              1.Java只支持单继承，不支持多继承。但支持多层继承
     *              2.Java中所有的类都直接或者间接的继承于Object类
     *
     *              子类只能访问父类中非私有的成员
     *
     *          好处：
     *              1.可以把多个子类中重复的代码抽取到父类中，提高代码的复用性
     *              2.子类可以在父类的基础上，增加其他的功能，使得子类更加强大，减少代码冗余
     *
     *
     *          继承中成员变量的访问特点：就近原则
     *              先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
     *
     *              name：默认优先从局部位置找，没找到找本类成员位置
     *              this.name：默认从本类成员位置找
     *              super.name:默认从父类成员位置找
     *
     *
     *
     *          方法重写：
     *              当父类的方法无法满足子类现在的需求时，需要进行方法重写
     *
     *              在继承体系当中，当子类出现了和父类一模一样的方法声明时，就称子类这个方法是重写方法
     *
     *          @Override重写注解：
     *              放在重写方法的上面，校验子类重写时语法是否准确
     *
     *
     *          继承中：构造方法的访问特点：
     *              1.父类中的构造方法不会被子类继承
     *              2.子类中的所有构造方法默认先访问父类中的无参构造，然后再执行自己
     *              3.子类构造方法的第一行，有一个默认的super();要先执行父类的无参构造方法。如果需要执行有参构造，就需要手动添加父类的有参构造方法
     *
     *
     *
     *      3.多态:
     *            同种类型的对象，表现出的不同形态
     *
     *            父类类型 对象名称 = 子类对象;
     *
     *        使用前提：
     *          1.有继承关系
     *          2.有父类引用指向子类对象
     *          3.有方法重写
     *
     *        好处：
     *          使用父类类型作为参数，可以接收所有子类对象.
     *
     *
     *        多态调用成员的特点：
     *           变量调用：
     *                  编译看左边： javac编译代码时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有，编译失败
     *                  运行看左边： java运行代码的时候，实际获取的就是左边的父类中成员变量的值
     *
     *           方法调用：
     *                  编译看左边： javac编译代码时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有，编译失败
     *                  运行看右边： java运行代码的时候，实际上获取的是右边的子类中成员变量的值
     *
     *       弊端：
     *          不能使用子类的特有功能;
     *          如果坚持使用，需要将父类对象，转换成子类对象，进行调用
     *          Fu f = new Zi();
     *          Zi zi = (Zi)f;
     *          zi.特有方法();
     *
     *          instanceof:判断一个类型是否是其他某一个类型
     *
     */

}
